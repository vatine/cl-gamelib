(in-package #:net.hexapodia.games-3d)

(defvar *camera* nil)

(defclass coord ()
  ((x :accessor x :initarg :x :type double-float)
   (y :accessor y :initarg :y :type double-float)
   (z :accessor z :initarg :z :type double-float)))

;;; We only need a camera that can yaw (no pitch or roll needed)
(defclass camera (coord)
  ((angle :accessor angle :initarg :angle :type double-float)
   (focal :accessor focal :initarg :focal) 
   ))

(defclass 3d-camera (coord)
  ((transform :reader transform :initarg :transform)))

(defun coord (x y z)
  (make-instance 'coord :x (coerce x 'double-float)
		 :y (coerce y 'double-float)
		 :z (coerce z 'double-float)))


(defmethod x ((ar array))
  (aref ar 0))
(defmethod y ((ar array))
  (aref ar 1))
(defmethod z ((ar array))
  (aref ar 2))


(defmethod (setf x) (new (ar array))
  (setf (aref ar 0) new))
(defmethod (setf y) (new (ar array))
  (setf (aref ar 1) new))
(defmethod (setf z) (new (ar array))
  (setf (aref ar 2) new))


(defun build-transform (transform)
  (let ((ar (make-array '(3 3)
			:element-type 'double-float
			:initial-contents (or transform
					      '((1.0d0 0.0d0 0.0d0)
						(0.0d0 1.0d0 0.0d0)
						(0.0d0 0.0d0 1.0d0))))))
    (rotatef (aref ar 0 1) (aref ar 1 0))
    (rotatef (aref ar 0 2) (aref ar 2 0))
    (rotatef (aref ar 1 2) (aref ar 2 1))
    ar))

(defun 3d-camera (x y z &optional transform)
  "Make a 3D camera at coordinate <X Y Z>, using the camera coordinate system
defined by the TRANSFORM sequence < Xbase Ybase Zbase > (the individual base
vectors can be expressed as arbritary sequences and they can be in an
arbritary sequence, they will be transformed by 3d-camera into something
sensible)."
  (make-instance '3d-camera
		 :x (coerce x 'double-float)
		 :y (coerce y 'double-float)
		 :z (coerce z 'double-float)
		 :transform (build-transform transform)))


(defgeneric world-to-camera (world-coord camera &optional result))
(defgeneric camera-to-screen (camera-coord camera &optional clip))
(defgeneric world-to-screen (world-coord camera &optional clip))

(defun base-transform (coord base &optional result)
  (let ((result (or result (make-instance 'coord)))
	(coord (vector (the-x coord) (the-y coord) (the-z coord)))) 
    (setf (the-x result)
	  (loop for n from 0 below 3
		sum (* (aref coord n)
		       (aref base n 0))))
    (setf (the-y result)
	  (loop for n from 0 below 3
		sum (* (aref coord n)
		       (aref base n 1))))
    (setf (the-z result)
	  (loop for n from 0 below 3
		sum (* (aref coord n)
		       (aref base n 2))))
    
    result))

(defun invert-transform (transform)
  (let ((xbase (vector 1.0d0 0.0d0 0.0d0))
	(ybase (vector 0.0d0 1.0d0 0.0d0))
	(zbase (vector 0.0d0 0.0d0 1.0d0)))
    (setf xbase (base-transform (vector 1.0d0 0.0d0 0.0d0) transform xbase))
    (setf ybase (base-transform (vector 0.0d0 1.0d0 0.0d0) transform ybase))
    (setf zbase (base-transform (vector 0.0d0 0.0d0 1.0d0) transform zbase))
    (build-transform (list xbase ybase zbase))))    

(defmethod world-to-camera (w c &optional result)
  (let ((x-tmp (- (the-x w) (the-x c)))
	(y-tmp (- (the-y w) (the-y c)))
	(z-tmp (- (the-z w) (the-z c)))
	(r1 (the-angle c))
	(r2 (+ (/ pi 2.0d0)
	       (the-angle c)))
	(result (or result (make-instance 'coord))))
    (declare (double-float x-tmp y-tmp z-tmp r1 r2))
    (setf (x result) (+ (* (cos r1) x-tmp)
			(* (cos r2) y-tmp)))
    (setf (y result) (+ (* (sin r1) x-tmp)
			(* (sin r2) y-tmp)))
    (setf (z result) z-tmp)
    result))

(defmethod world-to-camera (w (c 3d-camera) &optional result)
  (let ((x-tmp (- (the-x w) (the-x c)))
	(y-tmp (- (the-y w) (the-y c)))
	(z-tmp (- (the-z w) (the-z c)))
	(transform (transform c))
	(result (or result (make-instance 'coord))))
    (declare (double-float x-tmp y-tmp z-tmp)
	     ((array double-float (3 3)) transform))
    (base-transform (vector x-tmp y-tmp z-tmp) transform result)))

(defmethod camera-to-screen (coord cam &optional clip)
  (let ((div (/ (the-y coord) (focal cam)))
	(screen-half (truncate +screen-side+ 2)))
    (declare ((signed-byte 16) screen-half)
	     (double-float div))
    (let ((sx (if (zerop div) (the-x coord) (/ (the-x coord) div)))
	  (sy (if (zerop div) (the-z coord) (/ (the-z coord) div))))
      (cond ((and clip
		 (<= -1.0d0 sx 1.0d0)
		 (<= -1.0d0 sy 1.0d0))
	     (list (round (+ screen-half (* screen-half sx)))
		   (round (+ screen-half (* (- screen-half) sy)))))
	    ((not clip)
	     (list (round (+ screen-half (* screen-half sx)))
		   (round (+ screen-half (* (- screen-half) sy)))))
	    (t nil)))))

(defmethod camera-to-screen (coord (cam 3d-camera) &optional clip)
  (declare (ignore cam))
  (let ((screen-half (truncate +screen-side+ 2))
	(sx (if (zerop (the-y coord))
		(the-x coord)
	      (/ (the-x coord) (the-y coord))))
	(sy (if (zerop (the-y coord))
		(the-z coord)
	      (/ (the-z coord) (the-y coord)))))
      (declare ((signed-byte 16) screen-half))
      (cond ((and clip
		 (<= -1.0d0 sx 1.0d0)
		 (<= -1.0d0 sy 1.0d0))
	     (list (round (+ screen-half (* screen-half sx)))
		   (round (+ screen-half (* (- screen-half) sy)))))
	    ((not clip)
	     (list (round (+ screen-half (* screen-half sx)))
		   (round (+ screen-half (* (- screen-half) sy)))))
	    (t nil))))

(defmethod world-to-screen (w c &optional clip)
  (let ((screen-half (/ +screen-side+ 2))
	(x-tmp (- (the-x w) (the-x c)))
	(y-tmp (- (the-y w) (the-y c)))
	(z-tmp (- (the-z w) (the-z c)))
	(r1 (the-angle c))
	(r2 (+ (/ pi 2.0d0)
	       (the-angle c)))
	)
    (let ((cam-x (+ (* (cos r1) x-tmp)
		    (* (cos r2) y-tmp)))
	  (div (/ (+ (* (sin r1) x-tmp)
		     (* (sin r2) y-tmp))
		  (focal c)))
	  (cam-z z-tmp))
      (let ((sx (if (zerop div) cam-x (/ cam-x div)))
	    (sy (if (zerop div) cam-z (/ cam-z div))))
	(cond ((and clip
		 (<= -1.0d0 sx 1.0d0)
		 (<= -1.0d0 sy 1.0d0))
	     (list (round (+ screen-half (* screen-half sx)))
		   (round (+ screen-half (* (- screen-half) sy)))))
	    ((not clip)
	     (list (round (+ screen-half (* screen-half sx)))
		   (round (+ screen-half (* (- screen-half) sy)))))
	    (t nil))))))

(defmethod world-to-screen (world (cam 3d-camera) &optional clip)
  (let ((x-tmp (- (the-x world) (the-x cam)))
	(y-tmp (- (the-y world) (the-y cam)))
	(z-tmp (- (the-z world) (the-z cam))))
    (let ((coord (base-transform (vector x-tmp y-tmp z-tmp) (transform cam))))
      (let ((screen-half (truncate +screen-side+ 2))
	    (sx (if (zerop (the-y coord))
		    (the-x coord)
		  (/ (the-x coord) (the-y coord))))
	    (sy (if (zerop (the-y coord))
		    (the-z coord)
		  (/ (the-z coord) (the-y coord)))))
	(declare ((signed-byte 16) screen-half))
	(cond ((and clip
		    (<= -1.0d0 sx 1.0d0)
		    (<= -1.0d0 sy 1.0d0))
	       (list (round (+ screen-half (* screen-half sx)))
		     (round (+ screen-half (* (- screen-half) sy)))))
	      ((not clip)
	       (list (round (+ screen-half (* screen-half sx)))
		     (round (+ screen-half (* (- screen-half) sy)))))
	      (t nil))))))
	


(declaim (ftype (function (coord coord) double-float) distance))
(defun distance (c1 c2)
  (let ((dx (- (the-x c2) (the-x c1)))
	(dy (- (the-y c2) (the-y c1)))
	(dz (- (the-z c2) (the-z c1))))
    (declare (double-float dx dy dz))
    (sqrt (+ (square dx) (square dy) (square dz)))))
